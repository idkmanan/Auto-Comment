// const vscode = require('vscode');
// const { Ollama } = require('ollama');
// const ollama = new Ollama();

// /**
//  * @param {vscode.ExtensionContext} context
//  */
// function activate(context) {

// 	console.log('Congratulations, your extension "autocomment" is now active!');

// 	// let ghostComment = '';

// 	// vscode.languages.registerInlineCompletionItemProvider({ pattern: '**' }, {
// 	// 	provideInlineCompletionItems: (document, position, context, token) => {
// 	// 		if (!ghostComment) return;
	
// 	// 		const item = new vscode.InlineCompletionItem(ghostComment, position);
// 	// 		return [item];
// 	// 	}
// 	// });

// 	async function comment(userPrompt){
// 		let respText = "";
// 		try{
// 			const streamResponse = await ollama.chat({
// 				model: 'deepseek-r1:latest',
// 				messages: [{role:'user', content: userPrompt}],
// 				stream: true
// 			})

// 			for await (const part of streamResponse) {
// 				respText += part.message.content;
// 			}
// 			return respText
// 		}
// 		catch(e){
// 			return e;
// 		}
// 	} 

// 	const disposable = vscode.commands.registerCommand('autocomment.helloWorld', function () {
// 		const editor = vscode.window.activeTextEditor;

// 		let message = {command:"", text:""};

// 		if (editor) {
// 			const selection = editor.selection;
// 			const selectedText = editor.document.getText(selection);

// 			if (selectedText.trim().length === 0) {
// 				vscode.window.showInformationMessage('No text selected.');
// 				message.command = "no Text";
// 			} else {
// 				vscode.window.showInformationMessage(`Selected text: "${selectedText}"`);
// 				message.command = "chat";
// 				message.text = selectedText;
// 			}
// 		} else {
// 			vscode.window.showErrorMessage('No active editor.');
// 			message.command = "no Text";
// 		}

// 		if(message.command === "chat"){
// 			let userPrompt = message.text
// 			userPrompt += " (provide me a one line comment for the provided code)";
// 			comment(userPrompt).then(res =>{
// 				console.log("Final result:", res);
// 				// ghostComment = res;

// 				// // Trigger inline completion manually
// 				// vscode.commands.executeCommand('editor.action.inlineSuggest.trigger');
// 			})
// 		}
// 	});
	

// 	context.subscriptions.push(disposable);
// }

// function deactivate() {}

// module.exports = {
// 	activate,
// 	deactivate
// }

// -----------------------------------------------------------------------------------------------------

const vscode = require('vscode');
const { Ollama } = require('ollama');
const ollama = new Ollama();

let ghostComment = ''; // This becomes a real suggestion now

function activate(context) {
	console.log('Extension "autocomment" is active!');

	// Command to trigger comment generation
	const disposable = vscode.commands.registerCommand('autocomment.getComment', async () => {
		const editor = vscode.window.activeTextEditor;
		if (!editor) return;

		const selection = editor.selection;
		const selectedText = editor.document.getText(selection);
		const languageId = editor.document.languageId;

		if (!selectedText.trim()) {
			vscode.window.showInformationMessage('No code selected');
			return;
		}

		const prompt = `${selectedText} (provide a small comment for the above ${languageId} code)`;

		const result = await comment(prompt);

		ghostComment = ` ${result.replace(/\n/g, ' ').trim()}`;

		vscode.window.showInformationMessage('Comment generated. Type `//` to see suggestion.');
	});

	context.subscriptions.push(disposable);

	// Register a completion item provider
	const provider = vscode.languages.registerCompletionItemProvider(
		{ scheme: 'file', language: '*' }, // applies to all file types
		{
			provideCompletionItems(document, position) {
				const line = document.lineAt(position).text.substring(0, position.character);

				if (line.trim().endsWith('//')) {
					const item = new vscode.CompletionItem(ghostComment || '// [No comment generated]', vscode.CompletionItemKind.Text);
					item.insertText = ghostComment || '// [No comment generated]';
					item.detail = 'Generated by AutoComment';
					return [item];
				}
				return undefined;
			}
		},
		'/' // triggered when user types `/`
	);

	context.subscriptions.push(provider);

	//model change
	const setModelCommand = vscode.commands.registerCommand('autocomment.setModel', async () => {
		const models = ['qwen:0.5b', 'deepseek-r1:latest', 'wizardlm2:latest', 'qwen3:0.6b'];
	
		const selected = await vscode.window.showQuickPick(models, {
			placeHolder: 'Choose a model for AutoComment',
		});
	
		if (selected) {
			await vscode.workspace.getConfiguration('autocomment').update('model', selected, vscode.ConfigurationTarget.Global);
			vscode.window.showInformationMessage(`Model set to ${selected}`);
		}
	});
	
	context.subscriptions.push(setModelCommand);	
}

async function comment(userPrompt) {
	let respText = '';
	try {
		const config = vscode.workspace.getConfiguration('autocomment');
		const selectedModel = config.get('model') || 'qwen3:0.6b';

		const streamResponse = await ollama.chat({
			model: selectedModel,
			messages: [{ role: 'user', content: userPrompt }],
			stream: true
		});

		for await (const part of streamResponse) {
			respText += part.message.content;
		}
		return respText;
	} catch (e) {
		console.error(e);
		return '[Error generating comment]';
	}
}

function deactivate() {}

module.exports = {
	activate,
	deactivate
};
